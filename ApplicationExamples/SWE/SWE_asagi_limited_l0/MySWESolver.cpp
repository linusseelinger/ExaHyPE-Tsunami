// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "MySWESolver.h"
#include "MySWESolver_Variables.h"

#include "peano/utils/Loop.h"
#include "kernels/KernelUtils.h"
#include "../../../ExaHyPE/kernels/GaussLegendreBasis.h"
#include "InitialData.h"
#include "stdlib.h"

using namespace kernels;

tarch::logging::Log SWE::MySWESolver::_log( "SWE::MySWESolver" );

bool paramOutside = false;
namespace DG{
	double grav = 9.81*1.0e-3;
	double epsilon = 1.0e-2;
	InitialData* initialData;
}

void SWE::MySWESolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
	std::ifstream inputsfile("/tmp/inputs.txt");
	std::vector<double> param = {0.0,0.0};
	for (int i = 0; i < 2; i++) {
		inputsfile >> param[i];
	}
	inputsfile.close();
	if (param[0] > 739.0 || param[0] < -239.0 || param[1]>339.0 || param[1]<-339.0){ //reject parameters outside domain
		paramOutside = true;
	}

	DG::initialData = new InitialData(15,"data_gmt.yaml");
}


void SWE::MySWESolver::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
	if(paramOutside){
	    std::ofstream outputsfile("/tmp/outputs.txt");
	    typedef std::numeric_limits<double> dl;
	    outputsfile << std::fixed << std::setprecision(dl::digits10);
	    for(int i = 0; i<4; i++) outputsfile << 1234.0 << std::endl;
	    outputsfile.close();
	    for(int i = 0; i<4; i++) Q[i] = 0.0;
	}
	else{
  // Dimensions                        = 2
  // Number of variables + parameters  = 4 + 0
    if (tarch::la::equals(t,0.0)) {
	static tarch::multicore::BooleanSemaphore initializationSemaphoreDG;
	tarch::multicore::Lock lock(initializationSemaphoreDG);
	DG::initialData->getInitialData(x, Q);		
        lock.free();
    }
    //probe 1
    /*std::vector<std::vector<double>> probe_point = {{ 545.735266126, 62.7164740303 },
  						     { 1050.67821,   798.352124}};
    if(std::abs(x[0]-probe_point[0][0])<60.0 && std::abs(x[1]-probe_point[0][1])<60.0){
      if(Q[0]+Q[3] > DG::solution[1+2*0]){
	  DG::solution[0+2*0] = t; 
	  DG::solution[1+2*0] = Q[0]+Q[3];
      }
    }
    //probe 2
    if(std::abs(x[0]-probe_point[1][0])<60.0 && std::abs(x[1]-probe_point[1][1])<60.0){
      if(Q[0]+Q[3] > DG::solution[1+2*1]){
	  DG::solution[0+2*1] = t; 
	  DG::solution[1+2*1] = Q[0]+Q[3];
      }
    }
    if(t>5500.0 && isWritten==false){
	    std::ofstream outputsfile("/tmp/outputs.txt");
	    typedef std::numeric_limits<double> dl;
	    outputsfile << std::fixed << std::setprecision(dl::digits10);
	    outputsfile << DG::solution[0] << std::endl;
	    outputsfile << DG::solution[1] << std::endl;
	    outputsfile << DG::solution[2] << std::endl;
	    outputsfile << DG::solution[3] << std::endl;
	    outputsfile.close();	
	    isWritten = true;
    }*/
	}
}

void SWE::MySWESolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
  // Dimensions                        = 2
  // Number of variables + parameters  = 4 + 0
  //Wall
  std::copy_n(stateIn, NumberOfVariables, stateOut);
  stateOut[1+normalNonZero] =  -stateOut[1+normalNonZero];
  double _F[2][NumberOfVariables]={0.0};
  double* F[2] = {_F[0], _F[1]};
  flux(stateOut,F);
  std::copy_n(F[normalNonZero], NumberOfVariables, fluxOut);
}

exahype::solvers::Solver::RefinementControl SWE::MySWESolver::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int lev) {
	return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void SWE::MySWESolver::eigenvalues(const double* const Q,const int d,double* const lambda) {
  if(paramOutside)
	  lambda[0] = 1.0e-4;
  else{
  /// Dimensions                        = 2
  // Number of variables + parameters  = 4 + 0
  ReadOnlyVariables vars(Q);
  Variables eigs(lambda);

  const double c = std::sqrt(DG::grav*vars.h());
  const double ih = 1./vars.h();
  double u_n = Q[d + 1] * ih;

  eigs.h() = u_n + c;
  eigs.hu() = u_n - c;
  eigs.hv() = u_n;
  eigs.b() = 0.0;
}
}

void SWE::MySWESolver::flux(const double* const Q,double** const F) {
	// Dimensions                        = 2
	// Number of variables + parameters  = 4 + 0

	ReadOnlyVariables vars(Q);

	const double ih = 1./vars.h();

	double* f = F[0];
	double* g = F[1];

	if(paramOutside){
		f[0] = 0.0;
		f[1] = 0.0;
		f[2] = 0.0;
		f[3] = 0.0;

		g[0] = 0.0;
		g[1] = 0.0;
		g[2] = 0.0;
		g[3] = 0.0;
	}
	else{
		f[0] = vars.hu();
		// Moved hydrostatic pressure to ncp for well balancedness
		//f[1] = vars.hu() * vars.hu() * ih + 0.5 * DG::grav * vars.h() * vars.h();
		f[1] = vars.hu() * vars.hu() * ih;
		f[2] = vars.hu() * vars.hv() * ih;
		f[3] = 0.0;

		g[0] = vars.hv();
		g[1] = vars.hu() * vars.hv() * ih;
		// Moved hydrostatic pressure to ncp for well balancedness
		//g[2] = vars.hv() * vars.hv() * ih + 0.5 * DG::grav * vars.h() * vars.h();
		g[2] = vars.hv() * vars.hv() * ih;
		g[3] = 0.0;
	}
}

void  SWE::MySWESolver::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  idx2 idx_gradQ(DIMENSIONS,NumberOfVariables);
  BgradQ[0] = 0.0;
if(paramOutside){
  BgradQ[1] = 0.0;
  BgradQ[2] = 0.0;
}
else{
  BgradQ[1] = DG::grav*Q[0]*gradQ[idx_gradQ(0,3)] + DG::grav*Q[0]*gradQ[idx_gradQ(0,0)]; 
  BgradQ[2] = DG::grav*Q[0]*gradQ[idx_gradQ(1,3)] + DG::grav*Q[0]*gradQ[idx_gradQ(1,0)];
}
  BgradQ[3] = 0.0;
}

void SWE::MySWESolver::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double* gradQL, const double* gradQR, const double dt,const int direction,bool isBoundaryFace, int faceIndex) {
  constexpr int numberOfVariables  = NumberOfVariables;
  constexpr int numberOfData       = numberOfVariables;
  constexpr int order              = Order;
  constexpr int basisSize          = order+1;
  bool useNCP = true;

  // Compute the average variables and parameters from the left and the right
  double QavL[numberOfData] = {0.0}; // ~(numberOfVariables+numberOfParameters)
  double QavR[numberOfData] = {0.0}; // ~(numberOfVariables+numberOfParameters)
  {
    idx2 idx_QLR(basisSize, numberOfData);
    for (int j = 0; j < basisSize; j++) {
      const double weight = kernels::legendre::weights[order][j];

      for (int k = 0; k < numberOfData; k++) {
        QavL[k] += weight * QL[idx_QLR(j, k)];
        QavR[k] += weight * QR[idx_QLR(j, k)];
      }
    }
  }

  double LL[numberOfVariables] = {0.0}; // do not need to store material parameters
  double LR[numberOfVariables] = {0.0};
  eigenvalues(QavL, direction, LL);
  eigenvalues(QavR, direction, LR);

  // skip parameters
  std::transform(LL, LL + numberOfVariables, LL, std::abs<double>);
  std::transform(LR, LR + numberOfVariables, LR, std::abs<double>);
  const double* smax_L = std::max_element(LL, LL + numberOfVariables);
  const double* smax_R = std::max_element(LR, LR + numberOfVariables);
  const double smax    = std::max(*smax_L, *smax_R);

  // compute fluxes (and fluctuations for non-conservative PDEs)
  double Qavg[numberOfData];
  idx2 idx_gradQ(DIMENSIONS, numberOfVariables);
  double gradQ[DIMENSIONS][numberOfVariables] = {0.0};
  double ncp[numberOfVariables]               = {0.0};
    idx2 idx_FLR(basisSize, numberOfVariables);
    idx2 idx_QLR(basisSize, numberOfData);

    for (int j = 0; j < basisSize; j++) {

      if(useNCP) { // we don't use matrixB but the NCP call here.
        for(int l=0; l < numberOfVariables; l++) {
          gradQ[direction][l] = QR[idx_QLR(j, l)] - QL[idx_QLR(j, l)];
          Qavg[l] = 0.5 * (QR[idx_QLR(j, l)] + QL[idx_QLR(j, l)]);
        }

        nonConservativeProduct(Qavg, gradQ[0], ncp);
      }

      // skip parameters
      for (int k = 0; k < numberOfVariables; k++) {

        FL[idx_FLR(j, k)] =
            0.5 * (FR[idx_FLR(j, k)] + FL[idx_FLR(j, k)]) -
            0.5 * smax * (QR[idx_QLR(j, k)] - QL[idx_QLR(j, k)]);

	//to consider the bathmetry
	if(k == 0){
	  FL[idx_FLR(j, k)] -= 0.5 * smax * (QR[idx_QLR(j, 3)] - QL[idx_QLR(j, 3)]);
	}

        if(useNCP) {
          FR[idx_FLR(j, k)] = FL[idx_FLR(j, k)] - 0.5 * ncp[k];
          FL[idx_FLR(j, k)] = FL[idx_FLR(j, k)] + 0.5 * ncp[k];
        } else {
          FR[idx_FLR(j, k)] = FL[idx_FLR(j, k)];
        }

	if(k == 3){
	  //bathymetry doesn't change
          FR[idx_FLR(j, k)] = 0.0;
          FL[idx_FLR(j, k)] = 0.0;
	}
      }
    }

//   std::cout << "QL" << std::endl;
//   for (int j = 0; j < basisSize; j++) {
//       for (int k = 0; k < numberOfVariables; k++) {
// 	std::cout <<QL[idx_FLR(j,k)] << " ";
//       } std::cout << std::endl;
//   }
//   std::cout << "QR" << std::endl;
//   for (int j = 0; j < basisSize; j++) {
//       for (int k = 0; k < numberOfVariables; k++) {
// 	std::cout <<QR[idx_FLR(j,k)] << " ";
//       } std::cout << std::endl;
//   }

//   std::cout << "FL" << std::endl;
//   for (int j = 0; j < basisSize; j++) {
//       for (int k = 0; k < numberOfVariables; k++) {
// 	std::cout <<FL[idx_FLR(j,k)] << " ";
//       } std::cout << std::endl;
//   }

//   std::cout << "FR" << std::endl;
//   for (int j = 0; j < basisSize; j++) {
//       for (int k = 0; k < numberOfVariables; k++) {
// 	std::cout <<FR[idx_FLR(j,k)] << " ";
//       } std::cout << std::endl;
//   }



}
